<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/luciotato/waitfor"

    >wait.for (v0.6.6)</a>
</h1>
<h4>Sequential programming for node.js, end of callback hell</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.wait.for">module wait.for</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.for">
            function <span class="apidocSignatureSpan">wait.</span>for
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.applyAndWait">
            function <span class="apidocSignatureSpan">wait.for.</span>applyAndWait
            <span class="apidocSignatureSpan">(thisValue, fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.forMethod">
            function <span class="apidocSignatureSpan">wait.for.</span>forMethod
            <span class="apidocSignatureSpan">(obj, methodName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.launchFiber">
            function <span class="apidocSignatureSpan">wait.for.</span>launchFiber
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wait.for.</span>for.parallel</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wait.for.</span>parallel</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wait.for.parallel">module wait.for.parallel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.async_launch">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>async_launch
            <span class="apidocSignatureSpan">(functions, finalCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.fiberForItemBody">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>fiberForItemBody
            <span class="apidocSignatureSpan">(inx, context, functionAndArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.filter">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>filter
            <span class="apidocSignatureSpan">(arr, itemTestFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.launch">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>launch
            <span class="apidocSignatureSpan">(functions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.map">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>map
            <span class="apidocSignatureSpan">(arr, mappedFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wait.for.parallel.taskJoiner">
            function <span class="apidocSignatureSpan">wait.for.parallel.</span>taskJoiner
            <span class="apidocSignatureSpan">(inx, context, err, data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wait.for" id="apidoc.module.wait.for">module wait.for</a></h1>


    <h2>
        <a href="#apidoc.element.wait.for.for" id="apidoc.element.wait.for.for">
        function <span class="apidocSignatureSpan">wait.</span>for
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">for = function (fn){ // wait.for(fn,arg1,arg2,...)

    if (typeof fn !== &#x27;function&#x27;) throw new Error(&#x27;wait.for: first argument must be an async function&#x27;);

    var newargs=Array.prototype.slice.call(arguments,1); // remove function from args

    return wait.applyAndWait(null,fn,newargs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    print &#x22;caught:&#x22;, err.stack
    end nice function

---------------
###Aug-2013 - Wait.for-ES6 based on ES6-generators

I&#x27;ve developed ***a version based on JavaScript upcoming ES6-Harmony generators***. It&#x27;s not based on node-fibers.
***Surprisingly***, ES6 based implementation of *wait.<span class="apidocCodeKeywordSpan">for</span>(asyncFn)* is almost a no-op
, you can even completely omit it. *Warning: Bleeding edge*. Check [Wait.for-ES6] (https://github.com/luciotato/waitfor-ES6)

---------------


Install:
----
npm install wait.for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.applyAndWait" id="apidoc.element.wait.for.applyAndWait">
        function <span class="apidocSignatureSpan">wait.for.</span>applyAndWait
        <span class="apidocSignatureSpan">(thisValue, fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAndWait = function (thisValue, fn, args){ // like js fn.apply, but wait for results

    var fiber=Fiber.current;
    if (!fiber) throw new Error(&#x27;wait.for can only be called inside a fiber&#x27;);

    var fnName = fn.name;

    //create a closure to resume on callback
    var resumeCallback=function(err,data){
                        if (fiber.callbackAlreadyCalled)
                             throw new Error(&#x22;Callback for function &#x22;+fnName+&#x22; called twice. Wait.for already resumed the execution
.&#x22;);
                        fiber.callbackAlreadyCalled = true;
                        fiber.err=err; //store err on fiber object
                        fiber.data=data; //store data on fiber object
                        if (!fiber.yielded) {//when callback is called *before* async function returns
                            // no need to &#x22;resume&#x22; because we never got the chance to &#x22;yield&#x22;
                            return;
                        }
                        else {
                            //resume fiber after &#x22;yield&#x22;
                            fiber.run();
                        }
                    };

    args.push(resumeCallback);//add resumeCallback to arguments

    fiber.callbackAlreadyCalled=false;
    fiber.yielded = false;
    fn.apply(thisValue, args); //call async function/method
    if (!fiber.callbackAlreadyCalled) { //except callback was called before async fn return
        fiber.yielded = true;
        Fiber.yield(); //pause fiber, until callback =&#x3e; wait for results
    }

    if (fiber.err) throw fiber.err; //auto throw on error
    return fiber.data; //return data on success
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    ,for: function(fn){ // wait.for(fn,arg1,arg2,...)

if (typeof fn !== &#x27;function&#x27;) throw new Error(&#x27;wait.for: first argument must be an async function&#x27;);

var newargs=Array.prototype.slice.call(arguments,1); // remove function from args

return wait.<span class="apidocCodeKeywordSpan">applyAndWait</span>(null,fn,newargs);
    }

    ,forMethod: function(obj,methodName){ // wait.forMethod(MyObj,&#x27;select&#x27;,....)

var method=obj[methodName];
if (!method) throw new Error(&#x27;wait.forMethod: second argument must be the async method name (string)&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.forMethod" id="apidoc.element.wait.for.forMethod">
        function <span class="apidocSignatureSpan">wait.for.</span>forMethod
        <span class="apidocSignatureSpan">(obj, methodName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forMethod = function (obj, methodName){ // wait.forMethod(MyObj,&#x27;select&#x27;,....)

    var method=obj[methodName];
    if (!method) throw new Error(&#x27;wait.forMethod: second argument must be the async method name (string)&#x27;);

    var newargs=Array.prototype.slice.call(arguments,2); // remove obj and method name from args
    return wait.applyAndWait(obj,method,newargs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
***THE SAME CODE***, using **wait.for** (sequential logic - sequential programming):
```javascript
var db = require(&#x22;some-db-abstraction&#x22;), wait=require(&#x27;wait.for&#x27;);

function handleWithdrawal(req,res){
	try {
		var amount=req.param(&#x22;amount&#x22;);
		sessiondata = wait.<span class="apidocCodeKeywordSpan">forMethod</span>(db,&#x22;select&#x22;,&#x22;* from session where session_id
=?&#x22;,req.param(&#x22;session_id&#x22;));
		accountdata = wait.forMethod(db,&#x22;select&#x22;,&#x22;* from accounts where user_id=?&#x22;,sessiondata.user_ID);
		if (accountdata.balance &#x3c; amount) throw new Error(&#x27;insufficient funds&#x27;);
		wait.forMethod(db,&#x22;execute&#x22;,&#x22;withdrawal(?,?)&#x22;,accountdata.ID,req.param(&#x22;amount&#x22;));
		res.write(&#x22;withdrawal OK, amount: &#x22;+ req.param(&#x22;amount&#x22;));
		balance = wait.forMethod(db,&#x22;select&#x22;,&#x22;balance from accounts where account_id=?&#x22;, accountdata.ID);
		res.end(&#x22;your current balance is &#x22;  + balance.amount);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.launchFiber" id="apidoc.element.wait.for.launchFiber">
        function <span class="apidocSignatureSpan">wait.for.</span>launchFiber
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launchFiber = function (fn){ // wait.launchFiber(fn,arg1,arg2...)

    if (typeof fn !== &#x27;function&#x27;) throw new Error(&#x27;first argument must be a function&#x27;);
    var newargs=Array.prototype.slice.call(arguments,1); // remove function from args
    Fiber( function(){ fn.apply(null, newargs)} ).run(); //launch new fiber, call the fn with the args, this=null (strict)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You need to be in a Fiber to be able to use wait.for. The ideal place to launch a fiber
is when a request arrives, to handle it:

```javascript
var server = http.createServer(
  function(req, res){
    console.log(&#x27;req!&#x27;);
    wait.<span class="apidocCodeKeywordSpan">launchFiber</span>(handler,req,res); //handle in a fiber, keep node spinning
  }).listen(8000);
```

then,at *function handler(req,res)* and every function you call from there,
you&#x27;ll be able to use wait.for(ayncFn...

Examples:
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wait.for.parallel" id="apidoc.module.wait.for.parallel">module wait.for.parallel</a></h1>


    <h2>
        <a href="#apidoc.element.wait.for.parallel.async_launch" id="apidoc.element.wait.for.parallel.async_launch">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>async_launch
        <span class="apidocSignatureSpan">(functions, finalCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">async_launch = function (functions, finalCallback){
    //
    // functions:Array = [function,arg,arg..],[function,arg,arg,...],...
    // call finalCallback array with results of each func, a fiber is launched for each item
    // finalCallback is called when all functions complete
    //
    var context={results:[],count:0, expected:functions.length, finished:false, finalCallback:finalCallback};
    if (context.expected===0) return finalCallback(null,context.results);

    //launch a fiber for each item,
    // each item is an array containing function ptr and arguments
    for (var i = 0; i &#x3c; functions.length; i++) {
        wait.launchFiber(wait.parallel.fiberForItemBody,i,context,functions[i]);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.parallel.fiberForItemBody" id="apidoc.element.wait.for.parallel.fiberForItemBody">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>fiberForItemBody
        <span class="apidocSignatureSpan">(inx, context, functionAndArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fiberForItemBody = function (inx, context, functionAndArgs){
    //console.log(&#x27;fiber&#x27;,inx,&#x27;calling mappedFunction&#x27;,args);
    try{
        var data = functionAndArgs[0].apply(undefined,functionAndArgs.slice(1));
        wait.parallel.taskJoiner(inx,context,null,data);
    }
    catch(err){
        wait.parallel.taskJoiner(inx,context,err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.parallel.filter" id="apidoc.element.wait.for.parallel.filter">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>filter
        <span class="apidocSignatureSpan">(arr, itemTestFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (arr, itemTestFn){
    // must be in a Fiber
    //
    // mappedFn = function(item,index,arr) returns true/false
    //
    var testResults = wait.parallel.map(arr,itemTestFn);

    // create an array for each item where itemTestFn returned true
    var filteredArr=[];
    for (var i = 0; i &#x3c; arr.length; i++)
        if (testResults[i]) filteredArr.push(arr[i]);

    return filteredArr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

####returns:
- array with converted items
- do not &#x22;returns&#x22; until all fibers complete
- throws if error

-------------
###wait.parallel.<span class="apidocCodeKeywordSpan">filter</span>(arr:Array, itemTestFn:function)

Note: must be in a Fiber

####input:
- arr: Array
- itemTestFn = function(item,index,arr)
-- itemTestFn should return true|false. Since we&#x27;re in a fiber
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.parallel.launch" id="apidoc.element.wait.for.parallel.launch">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>launch
        <span class="apidocSignatureSpan">(functions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launch = function (functions){
    //
    // functions = [function,arg,arg],[function,arg,arg],...
    // returns array with results of each func, a fiber is launched for each item
    // wait.parallel.returns when all functions complete
    //
    return wait.for(wait.parallel.async_launch, functions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
```

Parallel Extensions
----------

-------------
###wait.parallel.<span class="apidocCodeKeywordSpan">launch</span>(functions:Array)

Note: must be in a Fiber

####input:
* functions: Array = [func,arg,arg],[func,arg,arg],...

####actions:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.parallel.map" id="apidoc.element.wait.for.parallel.map">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>map
        <span class="apidocSignatureSpan">(arr, mappedFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (arr, mappedFn){
    // must be in a Fiber
    //
    // mappedFn = function(item,index,arr) returns converted item, a fiber is launched for each item
    //
    // convert arr into an array of functions + parameters
    var functions = arr.map(function(item,inx){return [mappedFn,item,inx,arr]});
    // launch a fiber for each item. wait until all fibers complete
    return wait.parallel.launch(functions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
####returns:
- array with a result for each function
- do not &#x22;returns&#x22; until all fibers complete
- throws if error


-------------
###wait.parallel.<span class="apidocCodeKeywordSpan">map</span>(arr:Array, mappedFn:function)

Note: must be in a Fiber

####input:
- arr: Array
- mappedFn = function(item,index,arr)
-- mappedFn should return converted item. Since we&#x27;re in a fiber
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wait.for.parallel.taskJoiner" id="apidoc.element.wait.for.parallel.taskJoiner">
        function <span class="apidocSignatureSpan">wait.for.parallel.</span>taskJoiner
        <span class="apidocSignatureSpan">(inx, context, err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taskJoiner = function (inx, context, err, data){

        if (context.finished) return;

        context.count++;
        //console.log(&#x27;arrived result&#x27;,inx,err,data,&#x22;result.count&#x22;,context.count,&#x22;task&#x22;,context.taskId);

        if (err) {
            context.finished = true;
            return context.finalCallback(err); //err in one of the fibers
        }
        else
            context.results[inx]=data;

        if (context.count&#x3e;=context.expected) { // all contexts arrived
            //console.log(&#x22;finall callback. elements:&#x22;,context.count);
            context.finished = true;
            return context.finalCallback(null,context.results) ; // final callback
        }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
};

wait.parallel.fiberForItemBody = function(inx,context,functionAndArgs){
    //console.log(&#x27;fiber&#x27;,inx,&#x27;calling mappedFunction&#x27;,args);
    try{
        var data = functionAndArgs[0].apply(undefined,functionAndArgs.slice(1));
        wait.parallel.<span class="apidocCodeKeywordSpan">taskJoiner</span>(inx,context,null,data);
    }
    catch(err){
        wait.parallel.taskJoiner(inx,context,err);
    }
};
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
